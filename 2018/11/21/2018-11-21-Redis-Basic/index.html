
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>Redis 基础配置 | Kyle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Kyle Li">
    

    
    <meta name="description" content="Redis What RedisRedis（Remote Dictionary Server）实现分布式的内存数据结构项目，具有可选耐久性的内存键值数据库。Redis最初是在开发一个实时的 web 日志分析器的时候，为了解决可扩展性的问题而被创建的。在使用传统数据库系统扩展某些类型的工作负载遇到重大问题的背景下 Salvaore 开发了第一个Redis版本。 与其他数据库系统的不同Redis普遍认">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 基础配置">
<meta property="og:url" content="http://blogs.netkyle.com/2018/11/21/2018-11-21-Redis-Basic/index.html">
<meta property="og:site_name" content="Kyle">
<meta property="og:description" content="Redis What RedisRedis（Remote Dictionary Server）实现分布式的内存数据结构项目，具有可选耐久性的内存键值数据库。Redis最初是在开发一个实时的 web 日志分析器的时候，为了解决可扩展性的问题而被创建的。在使用传统数据库系统扩展某些类型的工作负载遇到重大问题的背景下 Salvaore 开发了第一个Redis版本。 与其他数据库系统的不同Redis普遍认">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-13T10:06:04.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 基础配置">
<meta name="twitter:description" content="Redis What RedisRedis（Remote Dictionary Server）实现分布式的内存数据结构项目，具有可选耐久性的内存键值数据库。Redis最初是在开发一个实时的 web 日志分析器的时候，为了解决可扩展性的问题而被创建的。在使用传统数据库系统扩展某些类型的工作负载遇到重大问题的背景下 Salvaore 开发了第一个Redis版本。 与其他数据库系统的不同Redis普遍认">

    
    <link rel="alternative" href="/atom.xml" title="Kyle" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Kyle" title="Kyle"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Kyle">Kyle</a></h1>
				<h2 class="blog-motto">LOVE CODE &amp; ENJOY LIFE</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:blogs.netkyle.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/11/21/2018-11-21-Redis-Basic/" title="Redis 基础配置" itemprop="url">Redis 基础配置</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kyle Li" target="_blank" itemprop="author">Kyle Li</a>
		
  <p class="article-time">
    <time datetime="2018-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2018-11-21</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-Redis"><span class="toc-number">1.</span> <span class="toc-text">What Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与其他数据库系统的不同"><span class="toc-number">2.</span> <span class="toc-text">与其他数据库系统的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持久化"><span class="toc-number">4.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制"><span class="toc-number">5.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能"><span class="toc-number">6.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-Docker-启动"><span class="toc-number">7.</span> <span class="toc-text">redis Docker 启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-命令行程序"><span class="toc-number">8.</span> <span class="toc-text">redis 命令行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#修改主机名"><span class="toc-number">8.1.</span> <span class="toc-text">修改主机名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改密码"><span class="toc-number">8.2.</span> <span class="toc-text">修改密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向指定数据库进行操作"><span class="toc-number">8.3.</span> <span class="toc-text">向指定数据库进行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从其他程序中获取输入"><span class="toc-number">8.4.</span> <span class="toc-text">从其他程序中获取输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连续不断执行相同的命令"><span class="toc-number">8.5.</span> <span class="toc-text">连续不断执行相同的命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用redis-cli大量插入数据"><span class="toc-number">8.6.</span> <span class="toc-text">使用redis-cli大量插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据输出"><span class="toc-number">8.7.</span> <span class="toc-text">数据输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行-Lua-脚本"><span class="toc-number">8.8.</span> <span class="toc-text">运行 Lua 脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互模式"><span class="toc-number">9.</span> <span class="toc-text">交互模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进入交互模式的方式"><span class="toc-number">9.1.</span> <span class="toc-text">进入交互模式的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理连接和重新连接"><span class="toc-number">9.2.</span> <span class="toc-text">处理连接和重新连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编辑、历史和结束"><span class="toc-number">9.3.</span> <span class="toc-text">编辑、历史和结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多次运行同一个命令"><span class="toc-number">9.4.</span> <span class="toc-text">多次运行同一个命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取-Redis-命令行的帮助"><span class="toc-number">9.5.</span> <span class="toc-text">获取 Redis 命令行的帮助</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊操作模式"><span class="toc-number">10.</span> <span class="toc-text">特殊操作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#持续状态模式"><span class="toc-number">10.1.</span> <span class="toc-text">持续状态模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-配置"><span class="toc-number">11.</span> <span class="toc-text">Redis 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置命令格式"><span class="toc-number">11.1.</span> <span class="toc-text">配置命令格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令行配置"><span class="toc-number">11.2.</span> <span class="toc-text">命令行配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时配置"><span class="toc-number">11.3.</span> <span class="toc-text">运行时配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将-Redis-配置为一个缓存（cache）"><span class="toc-number">11.4.</span> <span class="toc-text">将 Redis 配置为一个缓存（cache）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-持久化"><span class="toc-number">12.</span> <span class="toc-text">Redis 持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master-Slave-Replication-主从复制"><span class="toc-number">13.</span> <span class="toc-text">Master-Slave Replication 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置密码"><span class="toc-number">13.1.</span> <span class="toc-text">设置密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-命令"><span class="toc-number">14.</span> <span class="toc-text">Redis 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-类型的命令操作"><span class="toc-number">14.1.</span> <span class="toc-text">String 类型的命令操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASP-NET-Core-中使用-Redis"><span class="toc-number">15.</span> <span class="toc-text">ASP.NET Core 中使用 Redis</span></a></li></ol>
		
		</div>
		
		<p><a href="https://en.wikipedia.org/wiki/Redis" target="_blank" rel="noopener">Redis</a></p>
<h3 id="What-Redis"><a href="#What-Redis" class="headerlink" title="What Redis"></a>What Redis</h3><p>Redis（Remote Dictionary Server）实现分布式的内存数据结构项目，<br>具有可选耐久性的内存键值数据库。Redis最初是在开发一个实时的 web 日志分析器的时候，为了解决可扩展性的问题而被创建的。在使用传统数据库系统扩展某些类型的工作负载遇到重大问题的背景下 Salvaore 开发了第一个Redis版本。</p>
<h3 id="与其他数据库系统的不同"><a href="#与其他数据库系统的不同" class="headerlink" title="与其他数据库系统的不同"></a>与其他数据库系统的不同</h3><p>Redis普遍认为系统可以同时考虑存储和缓存，使用一种设计，这种设计可以使得数据可以一直保存在计算机内存中，以被读取和修改，但是也能以一种不适合随机访问数据，但仅在系统重新启动后重新构建数据到内存中的格式保存到磁盘中。<br>与关系数据库管理系统（RDBMS）相比，Redis提供的数据模型非常不寻常，因为用户命令不描述数据库引擎要执行的查询，而是对给定的抽象数据执行的特定操作 因此，数据必须以稍后适合快速检索的方式存储，而无需来自数据库系统的辅助索引，聚合或传统RDBMS的其他常见特征的帮助。<br>Redis实现大量使用Fork（系统调用）来复制保存数据的进程，以便父进程继续为客户端提供服务，而子进程在磁盘上创建数据的副本。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>字符串列表</li>
<li>字符串集合（未重复，未排序的元素的集合）</li>
<li>有序的字符串集合（通过一个称为分数的浮点数进行排序的非重复集合）</li>
<li>哈希表，键和值都为字符串</li>
<li>超重对数（HyperLogLogs）用于近似集基数大小估计</li>
<li>消费者群体的条目流，允许您使用自动存储多个字段和字符串值，每个键是一个基于时间的序列。</li>
<li>通过实现geohash技术的地理空间数据。</li>
</ul>
<p>值的类型决定了可以对值应用哪些操作。Redis 支持高等级的、原子的、服务端的操作，例如相交、合并、比较集合和有序列表的不同，以及集合与有序集合的不同。<br>基于Redis Modules API支持更多数据类型，Redis 的模块 RedisJson 实现了将 Json 作为原生数据类型。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis通常将整个数据集保存在内存中。2.4 以上的版本可以配置为使用它们所称的虚拟内存，其中一些数据集存储在磁盘上，但不推荐使用此功能。在Redis 中可以同通过两种途径实现持久化。第一种是通过快照的方式，这种方式将数据集作为二进制转存定期的从内存异步传输到磁盘上，使用 Redis 的RDB转存文件格式。或者通过日记功能，将修改数据集的每个操作的记录添加到后台进程中的仅附加文件（AOF）中。Redis可以在后台重写仅附加的文件，以避免日志无限期增长。日记在1.1版中引入，通常被认为是更安全的方法。<br>默认情况下，Redis至少每2秒将数据写入文件系统，如果需要，可以使用更多或更少的健壮选项。如果在默认设置下一个完整系统出现故障，则只会丢失几秒钟的数据。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Redis 支持主副本复制。来自任何 Redis 服务器的数据都可以复制到任意数量的副本。一个副本可能是另一个副本的主副本。这允许 Redis 实现单根复制树。Redis 副本可以配置为接受写入，允许实例之间有意和无意的不一致。发布/订阅功能已完全实现，因此副本的客户端可以订阅通道，并在复制树的任何位置接收发布到主服务器的完整消息。复制对于读取（但不是写入）可伸缩性或数据冗余非常有用。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当不需要数据的持久性时，与考虑提交事务之前将每个更改写入磁盘的数据库系统相比，Redis的内存中性质使其能够表现良好。Redis 作为单个进程运行，并且在重写 AOF（仅附加文件）时是单线程或双线程的。因此，单个Redis实例不能使用诸如存储过程之类的任务的并行执行。</p>
<h3 id="redis-Docker-启动"><a href="#redis-Docker-启动" class="headerlink" title="redis Docker 启动"></a>redis Docker 启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -v /home/kyle/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name redis01 -d  redis redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run </span><br><span class="line">-p 6379:6379</span><br><span class="line">-v /home/kyle/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf </span><br><span class="line">--name redis01</span><br><span class="line">-d  </span><br><span class="line">redis redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="redis-命令行程序"><a href="#redis-命令行程序" class="headerlink" title="redis 命令行程序"></a>redis 命令行程序</h3><p>Redis CLI 作为命令行程序的方式非常有利于脚本和某些类型的测试，但是大多人将会花费大部分时间在命令行的交互模式。</p>
<h4 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h4><ul>
<li><code>-h</code> 指定不同的主机名和IP地址<br><code>root@334dc022c633:/data# redis-cli -h 192.168.1.110 -p 6379 ping PONG</code></li>
</ul>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul>
<li><code>-a</code> 修改密码<br><code>root@334dc022c633:/data# redis-cli -a Netkyle ping PONG</code></li>
</ul>
<h4 id="向指定数据库进行操作"><a href="#向指定数据库进行操作" class="headerlink" title="向指定数据库进行操作"></a>向指定数据库进行操作</h4><p>指定向第几个数据库进行操作<br><code>root@334dc022c633:/data# redis-cli -n 5 set newkey &#39;kyle&#39;</code> </p>
<h4 id="从其他程序中获取输入"><a href="#从其他程序中获取输入" class="headerlink" title="从其他程序中获取输入"></a>从其他程序中获取输入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@334dc022c633:/usr/local/etc/redis# cat redis.conf </span><br><span class="line"><span class="meta">#</span>config</span><br><span class="line">root@334dc022c633:/usr/local/etc/redis# redis-cli -x set foo &lt; /usr/local/etc/redis/redis.conf </span><br><span class="line">OK</span><br><span class="line">root@334dc022c633:/usr/local/etc/redis# redis-cli getrange foo 0 10</span><br><span class="line">"#config\n"</span><br><span class="line">root@334dc022c633:/usr/local/etc/redis#</span><br></pre></td></tr></table></figure>

<p>另一种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> cat /tmp/commands.txt</span><br><span class="line">set foo 100</span><br><span class="line">incr foo</span><br><span class="line">append foo xxx</span><br><span class="line">get foo</span><br><span class="line"><span class="meta">$</span> cat /tmp/commands.txt | redis-cli</span><br><span class="line">OK</span><br><span class="line">(integer) 101</span><br><span class="line">(integer) 6</span><br><span class="line">"101xxx"</span><br></pre></td></tr></table></figure>

<h4 id="连续不断执行相同的命令"><a href="#连续不断执行相同的命令" class="headerlink" title="连续不断执行相同的命令"></a>连续不断执行相同的命令</h4><p>该功能由两个参数控制：<code>-r (count)</code> 和  <code>-i (delay)</code>，第一个参数指定执行多少次该命令，第二个参数配置在每个命令执行之间的时间间隔是多少，单位为秒，在使用<code>-r</code> 指定次数时，也可以将值指定为 -1，表示一直执行。</p>
<p><code>root@334dc022c633:/data# redis-cli -n 6 -r 5 -i 5 INFO | grep rss_human</code></p>
<p><code>-n</code> 表示对 第几个数据库操作<br><code>-r</code> 表示执行多少次<br><code>-i</code> 表示等待多久执行下一条命令</p>
<h4 id="使用redis-cli大量插入数据"><a href="#使用redis-cli大量插入数据" class="headerlink" title="使用redis-cli大量插入数据"></a>使用redis-cli大量插入数据</h4><p><a href="https://redis.io/topics/mass-insert" target="_blank" rel="noopener">https://redis.io/topics/mass-insert</a></p>
<h4 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h4><p>用时可能需要使用 redis-cli 快速导出数据到一个外部程序中，使用逗号分隔值（CSV）可以完成这个功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@334dc022c633:/data# redis-cli -n 9 lpush mylist a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">root@334dc022c633:/data# redis-cli -n 9 --csv lrange mylist 0 -1</span><br><span class="line">"d","c","b","a"</span><br></pre></td></tr></table></figure>

<p>目前，不可能像这样导出整个数据库，而只能用CSV输出运行单个命令。</p>
<h4 id="运行-Lua-脚本"><a href="#运行-Lua-脚本" class="headerlink" title="运行 Lua 脚本"></a>运行 Lua 脚本</h4><p>redis-cli广泛支持使用Lua脚本编写新的 Lua 调试工具，但是，即使不使用调试器，与以交互方式将脚本键入shell或作为参数相比，您可以使用redis-cli以更舒适的方式运行文件中的脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat /tmp/script.lua</span><br><span class="line">return redis.call('set',KEYS[1],ARGV[1])</span><br><span class="line"><span class="meta">$</span> redis-cli --eval /tmp/script.lua foo , bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><a href="https://redis.io/topics/ldb" target="_blank" rel="noopener">https://redis.io/topics/ldb</a></p>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>在交互模式下，用户在提示符下键入Redis命令。命令被发生到服务端、执行并，返回的回复被解析，并以更容易的方式呈现出来。<br>在运行CLI的交互模式时，不需要指定任何特殊的参数，仅仅在不提供任何的参数的加载就可以</p>
<h4 id="进入交互模式的方式"><a href="#进入交互模式的方式" class="headerlink" title="进入交互模式的方式"></a>进入交互模式的方式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@334dc022c633:/data# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; ping PONG</span><br><span class="line">"PONG"</span><br><span class="line">127.0.0.1:6379&gt; select 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; select 9</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[9]&gt; dbsize</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="处理连接和重新连接"><a href="#处理连接和重新连接" class="headerlink" title="处理连接和重新连接"></a>处理连接和重新连接</h4><p>使用 connect 命令 ，通过指定你想要连接的 hostname 和 port来连接到不同的实例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[9]&gt; connect metal 6379</span><br><span class="line">Could not connect to Redis at metal:6379: Name or service not known</span><br></pre></td></tr></table></figure>

<p>一般情况下，当一个断开的连接被检测到，CLI  通常尝试重新连接，如果尝试连接失败，它将显示错误信息并进入断开连接的状态。</p>
<p>如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; debug restart</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br><span class="line">not connected&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; (now we are connected again)</span><br></pre></td></tr></table></figure>

<p>当重新连接被执行，redis-cli 自动重新选择最后一个被选择的数据库。然而，所有关于连接的其他状态将丢失，例如处于事务的中间状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> redis-cli</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">( here the server is manually restarted )</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) ERR EXEC without MULTI</span><br></pre></td></tr></table></figure>

<h4 id="编辑、历史和结束"><a href="#编辑、历史和结束" class="headerlink" title="编辑、历史和结束"></a>编辑、历史和结束</h4><p>由于 redis-cli 使用linenoise线编辑库，它一直由编辑能力，没有依赖 libreadline 或者其他可选的类库。<br>为了避免一次又一次的重新输入，你可以访问命令执行的历史，通过使用上方向键和下方向键来查看。在重新启动CLI之间保留历史记录，这些内容被保存在用户 home目录下的 .rediscli_history 目录下，由HOME环境变量指定。同时 CLI 也支持 TAB 键。</p>
<h4 id="多次运行同一个命令"><a href="#多次运行同一个命令" class="headerlink" title="多次运行同一个命令"></a>多次运行同一个命令</h4><p>通过在要执行的命令前加上一个数字前缀，来实现多次运行同一个命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; 5 incr counter</span><br><span class="line">(integer) 5</span><br><span class="line">(integer) 6</span><br><span class="line">(integer) 7</span><br><span class="line">(integer) 8</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure>

<h4 id="获取-Redis-命令行的帮助"><a href="#获取-Redis-命令行的帮助" class="headerlink" title="获取 Redis 命令行的帮助"></a>获取 Redis 命令行的帮助</h4><ul>
<li><p><code>help @&lt;category&gt;</code> 显示给定分类的命令。这些分类有：<br>@generic, @list, @set, @sorted_set, @hash, @pubsub, @transactions, @connection, @server, @scripting, @hyperloglog.<br><code>127.0.0.1:6379[5]&gt; help @list</code></p>
</li>
<li><p><code>help @&lt;commandname&gt;</code> 显示指定命令的帮助信息<br><code>127.0.0.1:6379[5]&gt; help set</code></p>
</li>
</ul>
<h3 id="特殊操作模式"><a href="#特殊操作模式" class="headerlink" title="特殊操作模式"></a>特殊操作模式</h3><p>CLI会执行与Redis相关的其他辅助任务</p>
<ul>
<li>展示Redis Server运行状态的监控工具</li>
<li>扫描Redis数据库以获取非常大的Key。</li>
<li>具有模式匹配的关键空间扫描仪</li>
<li>作为 Pub/Sub 客户端订阅通道</li>
<li>监控 Redis 实例的命令执行</li>
<li>以不同的方式检查 Redis Server 的延迟</li>
<li>检查本地计算机的调度程序延迟</li>
<li>在本地获取远程 Redis Server中的 RDB备份</li>
<li>为了展示从站接受的数据，表现为为一个 Redis 从站</li>
<li>模拟LRU工作负载以显示有关键命中的统计信息。</li>
<li>Lua调试器的客户端。</li>
</ul>
<h4 id="持续状态模式"><a href="#持续状态模式" class="headerlink" title="持续状态模式"></a>持续状态模式</h4><p><code>root@334dc022c633:/data# redis-cli --stat</code></p>
<p><a href="https://redis.io/topics/rediscli" target="_blank" rel="noopener">命令行参考</a></p>
<h3 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h3><h4 id="配置命令格式"><a href="#配置命令格式" class="headerlink" title="配置命令格式"></a>配置命令格式</h4><p>redis.conf文件包含许多指令，指令的格式非常简单：如下</p>
<h4 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h4><p><code>keyword argument1 argument2 ... argumentN</code><br>可以通过命令行传递参数，这种方式非常适合用于测试的目的。所使用的格式除了要在关键字前添加 <code>--</code> 前缀外，其他都与在 redis.conf 中使用的方式相同。<br>如：<br><code>./redis-server --port 6380 --slaveof 127.0.0.1 6379</code></p>
<h4 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h4><p>在 Redis 运行时，可以在不重启Redis 服务的情况下，对Redis进行重新的配置。也可以以编程方式查询当前的Redis 服务配置。<br>config set ：添加配置<br>config get：查询配置</p>
<h4 id="将-Redis-配置为一个缓存（cache）"><a href="#将-Redis-配置为一个缓存（cache）" class="headerlink" title="将 Redis 配置为一个缓存（cache）"></a>将 Redis 配置为一个缓存（cache）</h4><p>如果仅仅打算使用 Redis 作为一个缓存，缓存中的每个 key 都有一个过期集间。可以使用以下配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 2mb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，没必要在应用中再使用 EXPIRE 命令设置 Key的生存时间，因为只要达到2兆字节的内存限制，所有Key都将使用近似 LRU 算法逐出。基本上在这种配置中，Redis的行为与memcached类似。<br><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">使用Redis作为 LRU缓存</a></p>
<h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>有两种方式:</p>
<ul>
<li>AOF (Append-only file)<br>启用该模式后，它会把每个操作都记录到系统文集里，如果Redistribution服务重启了，它会根据AOF这个文件重建整个数据集。这个文件会很快就变得很大，但是Redis 很聪明，它会使用里面最新版本的数据，并压缩文件到可控大小。<strong>默认不开启</strong>，通过修改 APPEND ONLU MODE 模块下的 appendonly 命令来修改。</li>
<li>RDB (Redis database file)<br>Redis 默认模式，它有点像数据库快照，创建一些时间点的数据，如果发生灾难，你可以从这些数据李进行恢复。当达到一些条件的时候，例如数据集里面再某段时间内新添加一定条目的数据，Redis 就会把数据做个快照，并写入RDB文件。<br>最佳实践时两者都使用，AOF 能够提升速度可可用性，RDB可以做灾难恢复。</li>
</ul>
<h3 id="Master-Slave-Replication-主从复制"><a href="#Master-Slave-Replication-主从复制" class="headerlink" title="Master-Slave Replication 主从复制"></a>Master-Slave Replication 主从复制</h3><ol>
<li><p>建立docker 网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kyle@kyle-ubuntu:~$ docker network create --driver bridge redis-net</span><br><span class="line">c6b8e810a4faadab8c2c8fe4c47bbd96e11fd31b667c8c92c210dde11f7b95d3</span><br><span class="line">kyle@kyle-ubuntu:~$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">02ef9e8e0178        bridge              bridge              local</span><br><span class="line">e02188c9f117        elastic             bridge              local</span><br><span class="line">1ac6654efefb        host                host                local</span><br><span class="line">d47e05c5fe88        none                null                local</span><br><span class="line">c6b8e810a4fa        redis-net           bridge              local</span><br><span class="line">kyle@kyle-ubuntu:~$</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 redis.conf 中绑定的IP地址：<br>将 bind 127.0.0.1 修改为 bind 0.0.0.0</p>
</li>
<li><p>创建 master 容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -p 6380:6379 -v /home/kyle/master-redis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name redis-master --network redis-net --rm redis redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中 <code>home/kyle/master-redis/conf/redis.conf</code> 为本地创建的配置文件。</p>
<ol start="4">
<li><p>参看 创建的网络 redis-net 的IP地址：<br><code>docker network inspect redis-net</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"Containers": &#123;</span><br><span class="line"> "32048c1124d9485d50dd795766492b210ff2374a9db3b9e2b0b0ecc5ff08d4a0": &#123;</span><br><span class="line">               "Name": "redis-master",</span><br><span class="line">               "EndpointID": "3dc4868930deaae8206a3359064ecd8a5e50e29ef93069970723407bc3ba90e5",</span><br><span class="line">               "MacAddress": "02:42:ac:13:00:02",</span><br><span class="line">               "IPv4Address": "172.19.0.2/16",</span><br><span class="line">               "IPv6Address": ""</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制 redis.conf （/home/kyle/master-redis/conf/redis.conf），将文件名命名为 redis2.conf,并修改redis2.conf 的 Replication 部分里的 replicaof 命名<br><code># slaveof &lt;masterip&gt; &lt;masterport&gt;</code><br><del><code>slaveof 172.19.0.2 6380</code></del><br><code>slaveof 172.19.0.2 6379</code><br>这里的IP地址要与master-redis的IP保持一致。<br>注意这里端口映射的时候 容器中的端口要使用 6379 ，我将端口设置为6380时，启动 从数据库 的容器时，抛出 <em>Error condition on socket for SYNC: Connection refused</em> 的错误</p>
</li>
<li><p>运行 redis 的slave容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kyle@kyle-ubuntu:~/master-redis/conf$ docker run -v /home/kyle/master-redis/conf/redis2.conf:/usr/local/etc/redis/redis2.conf --name slave-redis --network redis-net --rm redis redis-server /usr/local/etc/redis/redis2.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试主从是否工作正常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kyle@kyle-ubuntu:~/master-redis/conf$ docker exec -it redis-master redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set name kyle</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 25</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>进入命令行，执行一些操作，查看主备机是否都执行了这些操作。</p>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><ol>
<li>主从复制的master通常需要设置密码，修改redis.conf文件，找到requirepass这部分，取消注释并设置密码：</li>
<li>在slave的redis2.conf里，找到masterauth这部分，填写master的密码：<br><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">参考文档-持久化</a><br><a href="https://redis.io/topics/replication" target="_blank" rel="noopener">参考文档-主从复杂</a><br><a href="https://www.cnblogs.com/cgzl/p/10294175.html" target="_blank" rel="noopener">参考文档-应用</a></li>
</ol>
<h3 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h3><h4 id="String-类型的命令操作"><a href="#String-类型的命令操作" class="headerlink" title="String 类型的命令操作"></a>String 类型的命令操作</h4><ul>
<li>Set 和 Get</li>
<li>getset：设置后，将之前设置的值返回</li>
<li>incr,incrby 和 decr ,decrby：incr 自增，incrby 自增，可以指定增量；decr 自减，decrby ，自减，可以指定增量。</li>
<li>mset 和 mget：批量设置值与批量读取值</li>
<li>exists：判断 key 是否存在</li>
<li>del：删除 Key</li>
<li>type 检查类型</li>
<li>expire，ex，ttl：expire 设置 key的有效期，ex 在设置 key 的时候直接设置有效值；ttl 查看 key 还能存活多久。</li>
</ul>
<h3 id="ASP-NET-Core-中使用-Redis"><a href="#ASP-NET-Core-中使用-Redis" class="headerlink" title="ASP.NET Core 中使用 Redis"></a>ASP.NET Core 中使用 Redis</h3><p><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-2.2#distributed-redis-cache" target="_blank" rel="noopener">Redis 缓存</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.stackexchangeredis.rediscache?view=aspnetcore-2.2" target="_blank" rel="noopener">2.2版本及以上</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.redis.rediscache?view=aspnetcore-2.2" target="_blank" rel="noopener">2.2版本以以下</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ASP-NET-Core/">ASP.NET Core</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Redis/">Redis</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://blogs.netkyle.com/2018/11/21/2018-11-21-Redis-Basic/" data-title="Redis 基础配置 | Kyle" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/01/28/2019-01-28-Python-Basic/" title="Python 基础入门（一）">
  <strong>上一篇：</strong><br/>
  <span>
  Python 基础入门（一）</span>
</a>
</div>


<div class="next">
<a href="/2018/08/30/2018-08-30-AspNetCore-Options/"  title="Asp.Net Core 之 Options">
 <strong>下一篇：</strong><br/> 
 <span>Asp.Net Core 之 Options
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2018/11/21/2018-11-21-Redis-Basic/" data-title="Redis 基础配置" data-url="http://blogs.netkyle.com/2018/11/21/2018-11-21-Redis-Basic/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/ASP-NET-Core/" title="ASP.NET Core">ASP.NET Core<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Computer/" title="Computer">Computer<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tools/" title="Tools">Tools<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web/" title="Web">Web<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Configuration/" title="Configuration">Configuration<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Middleware/" title="Middleware">Middleware<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Host/" title="Host">Host<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Redis/" title="Redis">Redis<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python-basic/" title="Python basic">Python basic<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HTML/" title="HTML">HTML<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www.ruanyifeng.com/blog/" target="_blank" title="阮一峰的博客">阮一峰</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Kyle. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Kyle Li">Kyle Li</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"Kyle"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'Kyle';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>








<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
